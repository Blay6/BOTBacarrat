<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baccarat Predictor con LSTM (Atajos y Deshacer)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.13.0/dist/tf.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f4f4f9;
            padding: 20px;
        }
        .container {
            background-color: #ffffff;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            max-width: 700px;
            width: 100%;
        }
        h1 { color: #2c3e50; text-align: center; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
        .controls button {
            padding: 12px 18px;
            margin: 5px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        #banker-btn { background-color: #e74c3c; color: white; }
        #player-btn { background-color: #3498db; color: white; }
        #tie-btn { background-color: #2ecc71; color: white; }
        
        /* Estilos del bot√≥n Entrenar */
        #train-btn { background-color: #f39c12; color: white; } /* Color est√°ndar/Inicial */
        /* Nuevo estilo para sugerir reentrenamiento */
        #train-btn.suggest-retrain { 
            background-color: #2ecc71; /* Verde brillante */
            color: white; 
            animation: pulse 1s infinite;
        }

        #clear-btn { background-color: #95a5a6; color: white; }
        #undo-btn { background-color: #34495e; color: white; } 
        
        .history span {
            display: inline-block;
            padding: 5px 10px;
            margin: 3px;
            border-radius: 4px;
            color: white;
            font-weight: bold;
        }
        .B { background-color: #e74c3c; }
        .P { background-color: #3498db; }
        .T { background-color: #2ecc71; }

        .prediction {
            margin-top: 20px;
            padding: 15px;
            border: 2px dashed #2c3e50;
            border-radius: 8px;
            text-align: center;
        }
        #suggestion {
            font-size: 1.6em;
            font-weight: 700;
            margin-top: 10px;
        }
        .pred-B { background-color: #fceceb; color: #c0392b; }
        .pred-P { background-color: #e9f3fb; color: #2980b9; }
        .status { margin-top: 15px; font-style: italic; color: #7f8c8d; }

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(46, 204, 113, 0.7); }
            70% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(46, 204, 113, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(46, 204, 113, 0); }
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Baccarat Predictor con LSTM</h1>
    <p class="status" style="font-size: 0.8em; margin-bottom: 20px;">
        **Atajos:** Banca (B), Jugador (P), Empate (T), Deshacer (Z), Entrenar (E).
    </p>

    <div class="controls">
        <h2>Entrada de Datos:</h2>
        <button id="banker-btn">Banca (B)</button>
        <button id="player-btn">Jugador (P)</button>
        <button id="tie-btn">Empate (T)</button>
        <button id="undo-btn">Deshacer (Z)</button> 
        <button id="train-btn">Entrenar (E) üß†</button>
        <button id="clear-btn">Limpiar Datos</button>
        <p class="status" id="status-text">Modelo no entrenado. Ingresa datos y entrena.</p>
    </div>

    <div class="history">
        <h2>Historial:</h2>
        <div id="results-display">A√∫n no hay resultados...</div>
    </div>

    <div class="prediction">
        <h2>Predicci√≥n LSTM para la Siguiente Mano:</h2>
        <div id="suggestion">...</div>
        <p id="probability-text" style="font-size: 0.9em; margin-top: 10px;"></p>
    </div>
</div>

<script>
    // --- Configuraci√≥n LSTM y Variables Globales ---
    const LOOK_BACK = 10; 
    const FEATURE_SIZE = 3; 
    const results = []; 
    const REGISTERS_BEFORE_SUGGESTION = 3; // L√≠mite de 3 nuevos registros
    
    let model = null;
    let isTrained = false;
    let newRegistersSinceTrain = 0; // Contador de nuevos registros
    let needsRetrain = false; // Bandera para indicar que se debe reentrenar

    // Elementos del DOM
    const resultsDisplay = document.getElementById('results-display');
    const suggestionElement = document.getElementById('suggestion');
    const statusText = document.getElementById('status-text');
    const probabilityText = document.getElementById('probability-text');
    const trainButton = document.getElementById('train-btn'); // Referencia al bot√≥n
    
    // Mapeo de resultados: B=0, P=1, T=2
    const RESULT_MAP = { 'B': 0, 'P': 1, 'T': 2 };
    const INVERSE_MAP = ['Banca (B)', 'Jugador (P)'];
    
    // --- Funciones de Estado y UI ---

    function updateTrainButtonState() {
        if (isTrained && newRegistersSinceTrain >= REGISTERS_BEFORE_SUGGESTION) {
            // Sugerir reentrenamiento
            needsRetrain = true;
            trainButton.classList.add('suggest-retrain');
            statusText.textContent = `üö® ¬°${REGISTERS_BEFORE_SUGGESTION} nuevos resultados! Entrena de nuevo para una mejor precisi√≥n.`;
        } else if (isTrained) {
            // Entrenado pero sin suficientes datos nuevos para sugerir
            needsRetrain = false;
            trainButton.classList.remove('suggest-retrain');
            statusText.textContent = `Modelo entrenado. Resultados nuevos: ${newRegistersSinceTrain}.`;
        } else {
            // Nunca entrenado
            needsRetrain = false;
            trainButton.classList.remove('suggest-retrain');
            statusText.textContent = `Modelo no entrenado. Ingresa datos y entrena.`;
        }
    }

    function renderHistory() {
        if (results.length === 0) {
            resultsDisplay.innerHTML = 'A√∫n no hay resultados...';
            return;
        }
        const resultToClass = { 'B': 'B', 'P': 'P', 'T': 'T' };
        resultsDisplay.innerHTML = results.map(r => 
            `<span class="${resultToClass[r]}">${r}</span>`
        ).join('');
    }

    function addResult(result) {
        if (results.length >= 200) { 
            results.shift(); 
        }
        results.push(result);
        
        if (isTrained) {
            newRegistersSinceTrain++; // Incrementar solo si ya est√° entrenado
        }
        
        renderHistory();
        updateTrainButtonState(); // Actualizar el estado del bot√≥n/sugerencia
        
        if (isTrained) {
            predictNextHand();
        } else {
            suggestionElement.textContent = 'Ingresa resultados. Entrena para predecir.';
        }
    }

    function undoLastResult() {
        if (results.length > 0) {
            const lastResult = results.pop(); 
            
            // Si el modelo estaba entrenado, y deshacemos un registro nuevo, decrementamos el contador
            if (isTrained && newRegistersSinceTrain > 0) {
                newRegistersSinceTrain--;
            }
            
            renderHistory();
            updateTrainButtonState(); // Actualizar el estado del bot√≥n/sugerencia

            statusText.textContent = `Resultado '${lastResult}' deshecho.`;
            if (isTrained) {
                predictNextHand();
            } else if (results.length === 0) {
                suggestionElement.textContent = 'A√∫n no hay resultados...';
            }
        } else {
            statusText.textContent = "No hay resultados para deshacer.";
        }
    }

    // --- L√≥gica de Machine Learning ---

    function createModel() {
        if (model) model.dispose(); 
        model = tf.sequential();
        model.add(tf.layers.lstm({ inputShape: [LOOK_BACK, FEATURE_SIZE], units: 50, returnSequences: false }));
        model.add(tf.layers.dropout({ rate: 0.2 }));
        model.add(tf.layers.dense({ units: 2, activation: 'softmax' })); 
        model.compile({ optimizer: tf.train.adam(0.001), loss: 'categoricalCrossentropy', metrics: ['accuracy'] });
        updateTrainButtonState(); // Actualizar al crear
    }

    function preprocessData() {
        const encodedData = results.map(r => tf.oneHot(RESULT_MAP[r], FEATURE_SIZE).arraySync());
        if (encodedData.length < LOOK_BACK + 1) return null;

        const xs = []; 
        const ys = []; 
        for (let i = 0; i < encodedData.length - LOOK_BACK; i++) {
            const x = encodedData.slice(i, i + LOOK_BACK); 
            const yFull = encodedData[i + LOOK_BACK]; 
            if (yFull[2] === 1) continue; 
            xs.push(x);
            ys.push([yFull[0], yFull[1]]); 
        }
        
        if (xs.length === 0) return null;

        const inputTensor = tf.tensor3d(xs, [xs.length, LOOK_BACK, FEATURE_SIZE]);
        const outputTensor = tf.tensor2d(ys);
        return { inputTensor, outputTensor };
    }

    async function trainModel() {
        if (!model) createModel();

        const data = preprocessData();
        if (!data) {
            statusText.textContent = `Error: Se necesitan al menos ${LOOK_BACK + 1} resultados (B/P) para entrenamiento.`;
            return;
        }

        statusText.textContent = "Entrenando modelo LSTM... Por favor, espere. üß†";
        
        const history = await model.fit(data.inputTensor, data.outputTensor, {
            epochs: 100, 
            batchSize: 8,
            callbacks: {
                onEpochEnd: (epoch, logs) => {
                    statusText.textContent = `Entrenamiento: √âpoca ${epoch + 1}/100 - P√©rdida: ${logs.loss.toFixed(4)}`;
                }
            }
        });
        
        const finalLoss = history.history.loss[history.history.loss.length - 1].toFixed(4);
        isTrained = true;
        newRegistersSinceTrain = 0; // RESETEAR el contador de nuevos registros
        updateTrainButtonState(); // Actualizar el estado del bot√≥n
        statusText.textContent = `‚úÖ Entrenamiento LSTM completado. P√©rdida final: ${finalLoss}.`;
        predictNextHand(); 
    }

    function predictNextHand() {
        // L√≥gica de predicci√≥n (se mantiene)
        if (!isTrained) {
             // ... l√≥gica de no entrenado
             suggestionElement.textContent = 'Modelo sin entrenar. ¬°Presiona el bot√≥n de Entrenar!';
             probabilityText.textContent = '';
             suggestionElement.className = '';
             return;
        }

        const recentResults = results.slice(-LOOK_BACK);
        
        if (recentResults.length < LOOK_BACK) {
            suggestionElement.textContent = `Necesitas ${LOOK_BACK - recentResults.length} resultados m√°s para predecir.`;
            probabilityText.textContent = '';
            suggestionElement.className = '';
            return;
        }

        const encodedInput = recentResults.map(r => tf.oneHot(RESULT_MAP[r], FEATURE_SIZE).arraySync());
        const inputTensor = tf.tensor3d([encodedInput]); 
        
        const prediction = model.predict(inputTensor);
        const probabilities = prediction.dataSync(); 
        
        const BANKER_BIAS_FACTOR = 0.01; 
        let probBanca = probabilities[0] + BANKER_BIAS_FACTOR;
        let probJugador = probabilities[1] - BANKER_BIAS_FACTOR;

        const totalProb = probBanca + probJugador;
        probBanca /= totalProb;
        probJugador /= totalProb;

        const finalProbabilities = [probBanca, probJugador];
        const predictedIndex = tf.tensor1d(finalProbabilities).argMax().dataSync()[0];

        const predictedOutcome = INVERSE_MAP[predictedIndex];
        const probBancaFormatted = (probBanca * 100).toFixed(2);
        const probJugadorFormatted = (probJugador * 100).toFixed(2);
        
        suggestionElement.textContent = `Sugerencia LSTM: ${predictedOutcome}`;
        probabilityText.textContent = `Probabilidades (con sesgo): Banca ${probBancaFormatted}% | Jugador ${probJugadorFormatted}%`;

        if (predictedIndex === 0) {
            suggestionElement.className = 'pred-B';
        } else {
            suggestionElement.className = 'pred-P';
        }

        inputTensor.dispose();
        prediction.dispose();
    }

    // --- Event Listeners y Atajos (sin cambios) ---
    document.getElementById('banker-btn').addEventListener('click', () => addResult('B'));
    document.getElementById('player-btn').addEventListener('click', () => addResult('P'));
    document.getElementById('tie-btn').addEventListener('click', () => addResult('T'));
    document.getElementById('undo-btn').addEventListener('click', undoLastResult); 
    document.getElementById('train-btn').addEventListener('click', trainModel);

    document.getElementById('clear-btn').addEventListener('click', () => {
        results.length = 0;
        isTrained = false;
        model = null;
        newRegistersSinceTrain = 0;
        needsRetrain = false;
        renderHistory();
        suggestionElement.textContent = '...';
        probabilityText.textContent = '';
        statusText.textContent = 'Datos y modelo limpiados. Comienza de nuevo.';
        suggestionElement.className = '';
        createModel();
        updateTrainButtonState();
    });

    document.addEventListener('keydown', (event) => {
        const key = event.key.toUpperCase();
        
        if (key === 'B') { addResult('B'); document.getElementById('banker-btn').focus(); } 
        else if (key === 'P') { addResult('P'); document.getElementById('player-btn').focus(); } 
        else if (key === 'T') { addResult('T'); document.getElementById('tie-btn').focus(); } 
        else if (key === 'Z') { undoLastResult(); document.getElementById('undo-btn').focus(); } 
        else if (key === 'E') { trainModel(); document.getElementById('train-btn').focus(); }
    });

    // Inicializar el modelo y el estado del bot√≥n
    createModel();
    updateTrainButtonState();
</script>

</body>
</html>
